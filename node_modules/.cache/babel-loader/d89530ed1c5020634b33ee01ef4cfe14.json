{"ast":null,"code":"import _slicedToArray from \"/Users/a1/Documents/kholiavko-todo/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/a1/Documents/kholiavko-todo/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/a1/Documents/kholiavko-todo/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/a1/Documents/kholiavko-todo/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/a1/Documents/kholiavko-todo/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/Users/a1/Documents/kholiavko-todo/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n\n// src/devModeChecks/identityFunctionCheck.ts\nvar runIdentityFunctionCheck = function runIdentityFunctionCheck(resultFunc, inputSelectorsResults, outputSelectorResult) {\n  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {\n    var isInputSameAsOutput = false;\n\n    try {\n      var emptyObject = {};\n      if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true;\n    } catch (_unused) {}\n\n    if (isInputSameAsOutput) {\n      var stack = void 0;\n\n      try {\n        throw new Error();\n      } catch (e) {\n        ;\n        stack = e.stack;\n      }\n\n      console.warn(\"The result function returned its own inputs without modification. e.g\\n`createSelector([state => state.todos], todos => todos)`\\nThis could lead to inefficient memoization and unnecessary re-renders.\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.\", {\n        stack: stack\n      });\n    }\n  }\n}; // src/devModeChecks/inputStabilityCheck.ts\n\n\nvar runInputStabilityCheck = function runInputStabilityCheck(inputSelectorResultsObject, options, inputSelectorArgs) {\n  var memoize = options.memoize,\n      memoizeOptions = options.memoizeOptions;\n  var inputSelectorResults = inputSelectorResultsObject.inputSelectorResults,\n      inputSelectorResultsCopy = inputSelectorResultsObject.inputSelectorResultsCopy;\n  var createAnEmptyObject = memoize.apply(void 0, [function () {\n    return {};\n  }].concat(_toConsumableArray(memoizeOptions)));\n  var areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);\n\n  if (!areInputSelectorResultsEqual) {\n    var stack = void 0;\n\n    try {\n      throw new Error();\n    } catch (e) {\n      ;\n      stack = e.stack;\n    }\n\n    console.warn(\"An input selector returned a different result when passed same arguments.\\nThis means your output selector will likely run more frequently than intended.\\nAvoid returning a new reference inside your input selector, e.g.\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`\", {\n      arguments: inputSelectorArgs,\n      firstInputs: inputSelectorResults,\n      secondInputs: inputSelectorResultsCopy,\n      stack: stack\n    });\n  }\n}; // src/devModeChecks/setGlobalDevModeChecks.ts\n\n\nvar globalDevModeChecks = {\n  inputStabilityCheck: \"once\",\n  identityFunctionCheck: \"once\"\n};\n\nvar setGlobalDevModeChecks = function setGlobalDevModeChecks(devModeChecks) {\n  Object.assign(globalDevModeChecks, devModeChecks);\n}; // src/utils.ts\n\n\nvar NOT_FOUND = \"NOT_FOUND\";\n\nfunction assertIsFunction(func) {\n  var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected a function, instead received \".concat(typeof func);\n\n  if (typeof func !== \"function\") {\n    throw new TypeError(errorMessage);\n  }\n}\n\nfunction assertIsObject(object) {\n  var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected an object, instead received \".concat(typeof object);\n\n  if (typeof object !== \"object\") {\n    throw new TypeError(errorMessage);\n  }\n}\n\nfunction assertIsArrayOfFunctions(array) {\n  var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected all items to be functions, instead received the following types: \";\n\n  if (!array.every(function (item) {\n    return typeof item === \"function\";\n  })) {\n    var itemTypes = array.map(function (item) {\n      return typeof item === \"function\" ? \"function \".concat(item.name || \"unnamed\", \"()\") : typeof item;\n    }).join(\", \");\n    throw new TypeError(\"\".concat(errorMessage, \"[\").concat(itemTypes, \"]\"));\n  }\n}\n\nvar ensureIsArray = function ensureIsArray(item) {\n  return Array.isArray(item) ? item : [item];\n};\n\nfunction getDependencies(createSelectorArgs) {\n  var dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;\n  assertIsArrayOfFunctions(dependencies, \"createSelector expects all input-selectors to be functions, but received the following types: \");\n  return dependencies;\n}\n\nfunction collectInputSelectorResults(dependencies, inputSelectorArgs) {\n  var inputSelectorResults = [];\n  var length = dependencies.length;\n\n  for (var i = 0; i < length; i++) {\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));\n  }\n\n  return inputSelectorResults;\n}\n\nvar getDevModeChecksExecutionInfo = function getDevModeChecksExecutionInfo(firstRun, devModeChecks) {\n  var _globalDevModeChecks$ = _objectSpread(_objectSpread({}, globalDevModeChecks), devModeChecks),\n      identityFunctionCheck = _globalDevModeChecks$.identityFunctionCheck,\n      inputStabilityCheck = _globalDevModeChecks$.inputStabilityCheck;\n\n  return {\n    identityFunctionCheck: {\n      shouldRun: identityFunctionCheck === \"always\" || identityFunctionCheck === \"once\" && firstRun,\n      run: runIdentityFunctionCheck\n    },\n    inputStabilityCheck: {\n      shouldRun: inputStabilityCheck === \"always\" || inputStabilityCheck === \"once\" && firstRun,\n      run: runInputStabilityCheck\n    }\n  };\n}; // src/autotrackMemoize/autotracking.ts\n\n\nvar $REVISION = 0;\nvar CURRENT_TRACKER = null;\n\nvar Cell = /*#__PURE__*/function () {\n  function Cell(initialValue) {\n    var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tripleEq;\n\n    _classCallCheck(this, Cell);\n\n    _defineProperty(this, \"revision\", $REVISION);\n\n    _defineProperty(this, \"_value\", void 0);\n\n    _defineProperty(this, \"_lastValue\", void 0);\n\n    _defineProperty(this, \"_isEqual\", tripleEq);\n\n    this._value = this._lastValue = initialValue;\n    this._isEqual = isEqual;\n  } // Whenever a storage value is read, it'll add itself to the current tracker if\n  // one exists, entangling its state with that cache.\n\n\n  _createClass(Cell, [{\n    key: \"value\",\n    get: function get() {\n      var _CURRENT_TRACKER;\n\n      (_CURRENT_TRACKER = CURRENT_TRACKER) === null || _CURRENT_TRACKER === void 0 ? void 0 : _CURRENT_TRACKER.add(this);\n      return this._value;\n    } // Whenever a storage value is updated, we bump the global revision clock,\n    // assign the revision for this storage to the new value, _and_ we schedule a\n    // rerender. This is important, and it's what makes autotracking  _pull_\n    // based. We don't actively tell the caches which depend on the storage that\n    // anything has happened. Instead, we recompute the caches when needed.\n    ,\n    set: function set(newValue) {\n      if (this.value === newValue) return;\n      this._value = newValue;\n      this.revision = ++$REVISION;\n    }\n  }]);\n\n  return Cell;\n}();\n\nfunction tripleEq(a, b) {\n  return a === b;\n}\n\nvar TrackingCache = /*#__PURE__*/function () {\n  function TrackingCache(fn) {\n    _classCallCheck(this, TrackingCache);\n\n    _defineProperty(this, \"_cachedValue\", void 0);\n\n    _defineProperty(this, \"_cachedRevision\", -1);\n\n    _defineProperty(this, \"_deps\", []);\n\n    _defineProperty(this, \"hits\", 0);\n\n    _defineProperty(this, \"fn\", void 0);\n\n    this.fn = fn;\n  }\n\n  _createClass(TrackingCache, [{\n    key: \"clear\",\n    value: function clear() {\n      this._cachedValue = void 0;\n      this._cachedRevision = -1;\n      this._deps = [];\n      this.hits = 0;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      var _CURRENT_TRACKER2;\n\n      if (this.revision > this._cachedRevision) {\n        var fn = this.fn;\n        var currentTracker = /* @__PURE__ */new Set();\n        var prevTracker = CURRENT_TRACKER;\n        CURRENT_TRACKER = currentTracker;\n        this._cachedValue = fn();\n        CURRENT_TRACKER = prevTracker;\n        this.hits++;\n        this._deps = Array.from(currentTracker);\n        this._cachedRevision = this.revision;\n      }\n\n      (_CURRENT_TRACKER2 = CURRENT_TRACKER) === null || _CURRENT_TRACKER2 === void 0 ? void 0 : _CURRENT_TRACKER2.add(this);\n      return this._cachedValue;\n    }\n  }, {\n    key: \"revision\",\n    get: function get() {\n      return Math.max.apply(Math, _toConsumableArray(this._deps.map(function (d) {\n        return d.revision;\n      })).concat([0]));\n    }\n  }]);\n\n  return TrackingCache;\n}();\n\nfunction getValue(cell) {\n  if (!(cell instanceof Cell)) {\n    console.warn(\"Not a valid cell! \", cell);\n  }\n\n  return cell.value;\n}\n\nfunction setValue(storage, value) {\n  if (!(storage instanceof Cell)) {\n    throw new TypeError(\"setValue must be passed a tracked store created with `createStorage`.\");\n  }\n\n  storage.value = storage._lastValue = value;\n}\n\nfunction createCell(initialValue) {\n  var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tripleEq;\n  return new Cell(initialValue, isEqual);\n}\n\nfunction createCache(fn) {\n  assertIsFunction(fn, \"the first parameter to `createCache` must be a function\");\n  return new TrackingCache(fn);\n} // src/autotrackMemoize/tracking.ts\n\n\nvar neverEq = function neverEq(a, b) {\n  return false;\n};\n\nfunction createTag() {\n  return createCell(null, neverEq);\n}\n\nfunction dirtyTag(tag, value) {\n  setValue(tag, value);\n}\n\nvar consumeCollection = function consumeCollection(node) {\n  var tag = node.collectionTag;\n\n  if (tag === null) {\n    tag = node.collectionTag = createTag();\n  }\n\n  getValue(tag);\n};\n\nvar dirtyCollection = function dirtyCollection(node) {\n  var tag = node.collectionTag;\n\n  if (tag !== null) {\n    dirtyTag(tag, null);\n  }\n}; // src/autotrackMemoize/proxy.ts\n\n\nvar REDUX_PROXY_LABEL = Symbol();\nvar nextId = 0;\nvar proto = Object.getPrototypeOf({});\n\nvar ObjectTreeNode = /*#__PURE__*/_createClass(function ObjectTreeNode(value) {\n  _classCallCheck(this, ObjectTreeNode);\n\n  _defineProperty(this, \"proxy\", new Proxy(this, objectProxyHandler));\n\n  _defineProperty(this, \"tag\", createTag());\n\n  _defineProperty(this, \"tags\", {});\n\n  _defineProperty(this, \"children\", {});\n\n  _defineProperty(this, \"collectionTag\", null);\n\n  _defineProperty(this, \"id\", nextId++);\n\n  this.value = value;\n  this.value = value;\n  this.tag.value = value;\n});\n\nvar objectProxyHandler = {\n  get: function get(node, key) {\n    function calculateResult() {\n      var value = node.value;\n      var childValue = Reflect.get(value, key);\n\n      if (typeof key === \"symbol\") {\n        return childValue;\n      }\n\n      if (key in proto) {\n        return childValue;\n      }\n\n      if (typeof childValue === \"object\" && childValue !== null) {\n        var childNode = node.children[key];\n\n        if (childNode === void 0) {\n          childNode = node.children[key] = createNode(childValue);\n        }\n\n        if (childNode.tag) {\n          getValue(childNode.tag);\n        }\n\n        return childNode.proxy;\n      } else {\n        var tag = node.tags[key];\n\n        if (tag === void 0) {\n          tag = node.tags[key] = createTag();\n          tag.value = childValue;\n        }\n\n        getValue(tag);\n        return childValue;\n      }\n    }\n\n    var res = calculateResult();\n    return res;\n  },\n  ownKeys: function ownKeys(node) {\n    consumeCollection(node);\n    return Reflect.ownKeys(node.value);\n  },\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(node, prop) {\n    return Reflect.getOwnPropertyDescriptor(node.value, prop);\n  },\n  has: function has(node, prop) {\n    return Reflect.has(node.value, prop);\n  }\n};\n\nvar ArrayTreeNode = /*#__PURE__*/_createClass(function ArrayTreeNode(value) {\n  _classCallCheck(this, ArrayTreeNode);\n\n  _defineProperty(this, \"proxy\", new Proxy([this], arrayProxyHandler));\n\n  _defineProperty(this, \"tag\", createTag());\n\n  _defineProperty(this, \"tags\", {});\n\n  _defineProperty(this, \"children\", {});\n\n  _defineProperty(this, \"collectionTag\", null);\n\n  _defineProperty(this, \"id\", nextId++);\n\n  this.value = value;\n  this.value = value;\n  this.tag.value = value;\n});\n\nvar arrayProxyHandler = {\n  get: function get(_ref, key) {\n    var _ref2 = _slicedToArray(_ref, 1),\n        node = _ref2[0];\n\n    if (key === \"length\") {\n      consumeCollection(node);\n    }\n\n    return objectProxyHandler.get(node, key);\n  },\n  ownKeys: function ownKeys(_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 1),\n        node = _ref4[0];\n\n    return objectProxyHandler.ownKeys(node);\n  },\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(_ref5, prop) {\n    var _ref6 = _slicedToArray(_ref5, 1),\n        node = _ref6[0];\n\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop);\n  },\n  has: function has(_ref7, prop) {\n    var _ref8 = _slicedToArray(_ref7, 1),\n        node = _ref8[0];\n\n    return objectProxyHandler.has(node, prop);\n  }\n};\n\nfunction createNode(value) {\n  if (Array.isArray(value)) {\n    return new ArrayTreeNode(value);\n  }\n\n  return new ObjectTreeNode(value);\n}\n\nfunction updateNode(node, newValue) {\n  var value = node.value,\n      tags = node.tags,\n      children = node.children;\n  node.value = newValue;\n\n  if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {\n    dirtyCollection(node);\n  } else {\n    if (value !== newValue) {\n      var oldKeysSize = 0;\n      var newKeysSize = 0;\n      var anyKeysAdded = false;\n\n      for (var _key in value) {\n        oldKeysSize++;\n      }\n\n      for (var key in newValue) {\n        newKeysSize++;\n\n        if (!(key in value)) {\n          anyKeysAdded = true;\n          break;\n        }\n      }\n\n      var isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;\n\n      if (isDifferent) {\n        dirtyCollection(node);\n      }\n    }\n  }\n\n  for (var _key2 in tags) {\n    var childValue = value[_key2];\n    var newChildValue = newValue[_key2];\n\n    if (childValue !== newChildValue) {\n      dirtyCollection(node);\n      dirtyTag(tags[_key2], newChildValue);\n    }\n\n    if (typeof newChildValue === \"object\" && newChildValue !== null) {\n      delete tags[_key2];\n    }\n  }\n\n  for (var _key3 in children) {\n    var childNode = children[_key3];\n    var _newChildValue = newValue[_key3];\n    var _childValue = childNode.value;\n\n    if (_childValue === _newChildValue) {\n      continue;\n    } else if (typeof _newChildValue === \"object\" && _newChildValue !== null) {\n      updateNode(childNode, _newChildValue);\n    } else {\n      deleteNode(childNode);\n      delete children[_key3];\n    }\n  }\n}\n\nfunction deleteNode(node) {\n  if (node.tag) {\n    dirtyTag(node.tag, null);\n  }\n\n  dirtyCollection(node);\n\n  for (var key in node.tags) {\n    dirtyTag(node.tags[key], null);\n  }\n\n  for (var _key4 in node.children) {\n    deleteNode(node.children[_key4]);\n  }\n} // src/lruMemoize.ts\n\n\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n\n      return NOT_FOUND;\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getEntries: function getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear: function clear() {\n      entry = void 0;\n    }\n  };\n}\n\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    });\n\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex];\n\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n\n      return entry.value;\n    }\n\n    return NOT_FOUND;\n  }\n\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      entries.unshift({\n        key: key,\n        value: value\n      });\n\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n\n  function getEntries() {\n    return entries;\n  }\n\n  function clear() {\n    entries = [];\n  }\n\n  return {\n    get: get,\n    put: put,\n    getEntries: getEntries,\n    clear: clear\n  };\n}\n\nvar referenceEqualityCheck = function referenceEqualityCheck(a, b) {\n  return a === b;\n};\n\nfunction createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    }\n\n    var length = prev.length;\n\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}\n\nfunction lruMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = typeof equalityCheckOrOptions === \"object\" ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n      equalityCheck = _providedOptions$equa === void 0 ? referenceEqualityCheck : _providedOptions$equa,\n      _providedOptions$maxS = providedOptions.maxSize,\n      maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n      resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var resultsCount = 0;\n  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);\n\n  function memoized() {\n    var value = cache.get(arguments);\n\n    if (value === NOT_FOUND) {\n      value = func.apply(null, arguments);\n      resultsCount++;\n\n      if (resultEqualityCheck) {\n        var entries = cache.getEntries();\n        var matchingEntry = entries.find(function (entry) {\n          return resultEqualityCheck(entry.value, value);\n        });\n\n        if (matchingEntry) {\n          value = matchingEntry.value;\n          resultsCount !== 0 && resultsCount--;\n        }\n      }\n\n      cache.put(arguments, value);\n    }\n\n    return value;\n  }\n\n  memoized.clearCache = function () {\n    cache.clear();\n    memoized.resetResultsCount();\n  };\n\n  memoized.resultsCount = function () {\n    return resultsCount;\n  };\n\n  memoized.resetResultsCount = function () {\n    resultsCount = 0;\n  };\n\n  return memoized;\n} // src/autotrackMemoize/autotrackMemoize.ts\n\n\nfunction autotrackMemoize(func) {\n  var node = createNode([]);\n  var lastArgs = null;\n  var shallowEqual = createCacheKeyComparator(referenceEqualityCheck);\n  var cache = createCache(function () {\n    var res = func.apply(null, node.proxy);\n    return res;\n  });\n\n  function memoized() {\n    if (!shallowEqual(lastArgs, arguments)) {\n      updateNode(node, arguments);\n      lastArgs = arguments;\n    }\n\n    return cache.value;\n  }\n\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n\n  return memoized;\n} // src/weakMapMemoize.ts\n\n\nvar StrongRef = /*#__PURE__*/function () {\n  function StrongRef(value) {\n    _classCallCheck(this, StrongRef);\n\n    this.value = value;\n  }\n\n  _createClass(StrongRef, [{\n    key: \"deref\",\n    value: function deref() {\n      return this.value;\n    }\n  }]);\n\n  return StrongRef;\n}();\n\nvar Ref = typeof WeakRef !== \"undefined\" ? WeakRef : StrongRef;\nvar UNTERMINATED = 0;\nvar TERMINATED = 1;\n\nfunction createCacheNode() {\n  return {\n    s: UNTERMINATED,\n    v: void 0,\n    o: null,\n    p: null\n  };\n}\n\nfunction weakMapMemoize(func) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var fnNode = createCacheNode();\n  var resultEqualityCheck = options.resultEqualityCheck;\n  var lastResult;\n  var resultsCount = 0;\n\n  function memoized() {\n    var cacheNode = fnNode;\n    var length = arguments.length;\n\n    for (var i = 0, l = length; i < l; i++) {\n      var arg = arguments[i];\n\n      if (typeof arg === \"function\" || typeof arg === \"object\" && arg !== null) {\n        var objectCache = cacheNode.o;\n\n        if (objectCache === null) {\n          cacheNode.o = objectCache = /* @__PURE__ */new WeakMap();\n        }\n\n        var objectNode = objectCache.get(arg);\n\n        if (objectNode === void 0) {\n          cacheNode = createCacheNode();\n          objectCache.set(arg, cacheNode);\n        } else {\n          cacheNode = objectNode;\n        }\n      } else {\n        var primitiveCache = cacheNode.p;\n\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = /* @__PURE__ */new Map();\n        }\n\n        var primitiveNode = primitiveCache.get(arg);\n\n        if (primitiveNode === void 0) {\n          cacheNode = createCacheNode();\n          primitiveCache.set(arg, cacheNode);\n        } else {\n          cacheNode = primitiveNode;\n        }\n      }\n    }\n\n    var terminatedNode = cacheNode;\n    var result;\n\n    if (cacheNode.s === TERMINATED) {\n      result = cacheNode.v;\n    } else {\n      result = func.apply(null, arguments);\n      resultsCount++;\n    }\n\n    terminatedNode.s = TERMINATED;\n\n    if (resultEqualityCheck) {\n      var _lastResult$deref, _lastResult, _lastResult$deref2;\n\n      var lastResultValue = (_lastResult$deref = (_lastResult = lastResult) === null || _lastResult === void 0 ? void 0 : (_lastResult$deref2 = _lastResult.deref) === null || _lastResult$deref2 === void 0 ? void 0 : _lastResult$deref2.call(_lastResult)) !== null && _lastResult$deref !== void 0 ? _lastResult$deref : lastResult;\n\n      if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {\n        result = lastResultValue;\n        resultsCount !== 0 && resultsCount--;\n      }\n\n      var needsWeakRef = typeof result === \"object\" && result !== null || typeof result === \"function\";\n      lastResult = needsWeakRef ? new Ref(result) : result;\n    }\n\n    terminatedNode.v = result;\n    return result;\n  }\n\n  memoized.clearCache = function () {\n    fnNode = createCacheNode();\n    memoized.resetResultsCount();\n  };\n\n  memoized.resultsCount = function () {\n    return resultsCount;\n  };\n\n  memoized.resetResultsCount = function () {\n    resultsCount = 0;\n  };\n\n  return memoized;\n} // src/createSelectorCreator.ts\n\n\nfunction createSelectorCreator(memoizeOrOptions) {\n  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key5 = 1; _key5 < _len; _key5++) {\n    memoizeOptionsFromArgs[_key5 - 1] = arguments[_key5];\n  }\n\n  var createSelectorCreatorOptions = typeof memoizeOrOptions === \"function\" ? {\n    memoize: memoizeOrOptions,\n    memoizeOptions: memoizeOptionsFromArgs\n  } : memoizeOrOptions;\n\n  var createSelector2 = function createSelector2() {\n    for (var _len2 = arguments.length, createSelectorArgs = new Array(_len2), _key6 = 0; _key6 < _len2; _key6++) {\n      createSelectorArgs[_key6] = arguments[_key6];\n    }\n\n    var _recomputations = 0;\n    var _dependencyRecomputations = 0;\n\n    var _lastResult2;\n\n    var directlyPassedOptions = {};\n    var resultFunc = createSelectorArgs.pop();\n\n    if (typeof resultFunc === \"object\") {\n      directlyPassedOptions = resultFunc;\n      resultFunc = createSelectorArgs.pop();\n    }\n\n    assertIsFunction(resultFunc, \"createSelector expects an output function after the inputs, but received: [\".concat(typeof resultFunc, \"]\"));\n\n    var combinedOptions = _objectSpread(_objectSpread({}, createSelectorCreatorOptions), directlyPassedOptions);\n\n    var memoize = combinedOptions.memoize,\n        _combinedOptions$memo = combinedOptions.memoizeOptions,\n        memoizeOptions = _combinedOptions$memo === void 0 ? [] : _combinedOptions$memo,\n        _combinedOptions$args = combinedOptions.argsMemoize,\n        argsMemoize = _combinedOptions$args === void 0 ? weakMapMemoize : _combinedOptions$args,\n        _combinedOptions$args2 = combinedOptions.argsMemoizeOptions,\n        argsMemoizeOptions = _combinedOptions$args2 === void 0 ? [] : _combinedOptions$args2,\n        _combinedOptions$devM = combinedOptions.devModeChecks,\n        devModeChecks = _combinedOptions$devM === void 0 ? {} : _combinedOptions$devM;\n    var finalMemoizeOptions = ensureIsArray(memoizeOptions);\n    var finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);\n    var dependencies = getDependencies(createSelectorArgs);\n    var memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {\n      _recomputations++;\n      return resultFunc.apply(null, arguments);\n    }].concat(_toConsumableArray(finalMemoizeOptions)));\n    var firstRun = true;\n    var selector = argsMemoize.apply(void 0, [function dependenciesChecker() {\n      _dependencyRecomputations++;\n      var inputSelectorResults = collectInputSelectorResults(dependencies, arguments);\n      _lastResult2 = memoizedResultFunc.apply(null, inputSelectorResults);\n\n      if (process.env.NODE_ENV !== \"production\") {\n        var _getDevModeChecksExec = getDevModeChecksExecutionInfo(firstRun, devModeChecks),\n            identityFunctionCheck = _getDevModeChecksExec.identityFunctionCheck,\n            inputStabilityCheck = _getDevModeChecksExec.inputStabilityCheck;\n\n        if (identityFunctionCheck.shouldRun) {\n          identityFunctionCheck.run(resultFunc, inputSelectorResults, _lastResult2);\n        }\n\n        if (inputStabilityCheck.shouldRun) {\n          var inputSelectorResultsCopy = collectInputSelectorResults(dependencies, arguments);\n          inputStabilityCheck.run({\n            inputSelectorResults: inputSelectorResults,\n            inputSelectorResultsCopy: inputSelectorResultsCopy\n          }, {\n            memoize: memoize,\n            memoizeOptions: finalMemoizeOptions\n          }, arguments);\n        }\n\n        if (firstRun) firstRun = false;\n      }\n\n      return _lastResult2;\n    }].concat(_toConsumableArray(finalArgsMemoizeOptions)));\n    return Object.assign(selector, {\n      resultFunc: resultFunc,\n      memoizedResultFunc: memoizedResultFunc,\n      dependencies: dependencies,\n      dependencyRecomputations: function dependencyRecomputations() {\n        return _dependencyRecomputations;\n      },\n      resetDependencyRecomputations: function resetDependencyRecomputations() {\n        _dependencyRecomputations = 0;\n      },\n      lastResult: function lastResult() {\n        return _lastResult2;\n      },\n      recomputations: function recomputations() {\n        return _recomputations;\n      },\n      resetRecomputations: function resetRecomputations() {\n        _recomputations = 0;\n      },\n      memoize: memoize,\n      argsMemoize: argsMemoize\n    });\n  };\n\n  Object.assign(createSelector2, {\n    withTypes: function withTypes() {\n      return createSelector2;\n    }\n  });\n  return createSelector2;\n}\n\nvar createSelector = /* @__PURE__ */createSelectorCreator(weakMapMemoize); // src/createStructuredSelector.ts\n\nvar createStructuredSelector = Object.assign(function (inputSelectorsObject) {\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\n  assertIsObject(inputSelectorsObject, \"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a \".concat(typeof inputSelectorsObject));\n  var inputSelectorKeys = Object.keys(inputSelectorsObject);\n  var dependencies = inputSelectorKeys.map(function (key) {\n    return inputSelectorsObject[key];\n  });\n  var structuredSelector = selectorCreator(dependencies, function () {\n    for (var _len3 = arguments.length, inputSelectorResults = new Array(_len3), _key7 = 0; _key7 < _len3; _key7++) {\n      inputSelectorResults[_key7] = arguments[_key7];\n    }\n\n    return inputSelectorResults.reduce(function (composition, value, index) {\n      composition[inputSelectorKeys[index]] = value;\n      return composition;\n    }, {});\n  });\n  return structuredSelector;\n}, {\n  withTypes: function withTypes() {\n    return createStructuredSelector;\n  }\n});\nexport { createSelector, createSelectorCreator, createStructuredSelector, lruMemoize, referenceEqualityCheck, setGlobalDevModeChecks, autotrackMemoize as unstable_autotrackMemoize, weakMapMemoize };","map":{"version":3,"mappings":"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","names":["runIdentityFunctionCheck","resultFunc","inputSelectorsResults","outputSelectorResult","length","isInputSameAsOutput","emptyObject","stack","Error","e","console","warn","runInputStabilityCheck","inputSelectorResultsObject","options","inputSelectorArgs","memoize","memoizeOptions","inputSelectorResults","inputSelectorResultsCopy","createAnEmptyObject","areInputSelectorResultsEqual","apply","arguments","firstInputs","secondInputs","globalDevModeChecks","inputStabilityCheck","identityFunctionCheck","setGlobalDevModeChecks","devModeChecks","Object","assign","NOT_FOUND","assertIsFunction","func","errorMessage","TypeError","assertIsObject","object","assertIsArrayOfFunctions","array","every","item","itemTypes","map","name","join","ensureIsArray","Array","isArray","getDependencies","createSelectorArgs","dependencies","collectInputSelectorResults","i","push","getDevModeChecksExecutionInfo","firstRun","shouldRun","run","$REVISION","CURRENT_TRACKER","Cell","initialValue","isEqual","tripleEq","_value","_lastValue","_isEqual","add","newValue","value","revision","a","b","TrackingCache","fn","_cachedValue","_cachedRevision","_deps","hits","currentTracker","Set","prevTracker","from","Math","max","d","getValue","cell","setValue","storage","createCell","createCache","neverEq","createTag","dirtyTag","tag","consumeCollection","node","collectionTag","dirtyCollection","REDUX_PROXY_LABEL","Symbol","nextId","proto","getPrototypeOf","ObjectTreeNode","Proxy","objectProxyHandler","get","key","calculateResult","childValue","Reflect","childNode","children","createNode","proxy","tags","res","ownKeys","getOwnPropertyDescriptor","prop","has","ArrayTreeNode","arrayProxyHandler","updateNode","oldKeysSize","newKeysSize","anyKeysAdded","_key","isDifferent","newChildValue","deleteNode","createSingletonCache","equals","entry","put","getEntries","clear","createLruCache","maxSize","entries","cacheIndex","findIndex","splice","unshift","pop","referenceEqualityCheck","createCacheKeyComparator","equalityCheck","areArgumentsShallowlyEqual","prev","next","lruMemoize","equalityCheckOrOptions","providedOptions","resultEqualityCheck","comparator","resultsCount","cache","memoized","matchingEntry","find","clearCache","resetResultsCount","autotrackMemoize","lastArgs","shallowEqual","StrongRef","Ref","WeakRef","UNTERMINATED","TERMINATED","createCacheNode","s","v","o","p","weakMapMemoize","fnNode","lastResult","cacheNode","l","arg","objectCache","WeakMap","objectNode","set","primitiveCache","Map","primitiveNode","terminatedNode","result","lastResultValue","deref","needsWeakRef","createSelectorCreator","memoizeOrOptions","memoizeOptionsFromArgs","createSelectorCreatorOptions","createSelector","recomputations","dependencyRecomputations","directlyPassedOptions","combinedOptions","argsMemoize","argsMemoizeOptions","finalMemoizeOptions","finalArgsMemoizeOptions","memoizedResultFunc","recomputationWrapper","selector","dependenciesChecker","process","env","NODE_ENV","resetDependencyRecomputations","resetRecomputations","withTypes","createStructuredSelector","inputSelectorsObject","selectorCreator","inputSelectorKeys","keys","structuredSelector","reduce","composition","index"],"sources":["/Users/a1/Documents/kholiavko-todo/node_modules/reselect/src/devModeChecks/identityFunctionCheck.ts","/Users/a1/Documents/kholiavko-todo/node_modules/reselect/src/devModeChecks/inputStabilityCheck.ts","/Users/a1/Documents/kholiavko-todo/node_modules/reselect/src/devModeChecks/setGlobalDevModeChecks.ts","/Users/a1/Documents/kholiavko-todo/node_modules/reselect/src/utils.ts","/Users/a1/Documents/kholiavko-todo/node_modules/reselect/src/autotrackMemoize/autotracking.ts","/Users/a1/Documents/kholiavko-todo/node_modules/reselect/src/autotrackMemoize/tracking.ts","/Users/a1/Documents/kholiavko-todo/node_modules/reselect/src/autotrackMemoize/proxy.ts","/Users/a1/Documents/kholiavko-todo/node_modules/reselect/src/lruMemoize.ts","/Users/a1/Documents/kholiavko-todo/node_modules/reselect/src/autotrackMemoize/autotrackMemoize.ts","/Users/a1/Documents/kholiavko-todo/node_modules/reselect/src/weakMapMemoize.ts","/Users/a1/Documents/kholiavko-todo/node_modules/reselect/src/createSelectorCreator.ts","/Users/a1/Documents/kholiavko-todo/node_modules/reselect/src/createStructuredSelector.ts"],"sourcesContent":["import type { AnyFunction } from '../types'\n\n/**\n * Runs a check to determine if the given result function behaves as an\n * identity function. An identity function is one that returns its\n * input unchanged, for example, `x => x`. This check helps ensure\n * efficient memoization and prevent unnecessary re-renders by encouraging\n * proper use of transformation logic in result functions and\n * extraction logic in input selectors.\n *\n * @param resultFunc - The result function to be checked.\n * @param inputSelectorsResults - The results of the input selectors.\n * @param outputSelectorResult - The result of the output selector.\n *\n * @see {@link https://reselect.js.org/api/development-only-stability-checks#identityfunctioncheck `identityFunctionCheck`}\n *\n * @since 5.0.0\n * @internal\n */\nexport const runIdentityFunctionCheck = (\n  resultFunc: AnyFunction,\n  inputSelectorsResults: unknown[],\n  outputSelectorResult: unknown\n) => {\n  if (\n    inputSelectorsResults.length === 1 &&\n    inputSelectorsResults[0] === outputSelectorResult\n  ) {\n    let isInputSameAsOutput = false\n    try {\n      const emptyObject = {}\n      if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true\n    } catch {\n      // Do nothing\n    }\n    if (isInputSameAsOutput) {\n      let stack: string | undefined = undefined\n      try {\n        throw new Error()\n      } catch (e) {\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi, no-extra-semi\n        ;({ stack } = e as Error)\n      }\n      console.warn(\n        'The result function returned its own inputs without modification. e.g' +\n          '\\n`createSelector([state => state.todos], todos => todos)`' +\n          '\\nThis could lead to inefficient memoization and unnecessary re-renders.' +\n          '\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.',\n        { stack }\n      )\n    }\n  }\n}\n","import type { CreateSelectorOptions, UnknownMemoizer } from '../types'\n\n/**\n * Runs a stability check to ensure the input selector results remain stable\n * when provided with the same arguments. This function is designed to detect\n * changes in the output of input selectors, which can impact the performance of memoized selectors.\n *\n * @param inputSelectorResultsObject - An object containing two arrays: `inputSelectorResults` and `inputSelectorResultsCopy`, representing the results of input selectors.\n * @param options - Options object consisting of a `memoize` function and a `memoizeOptions` object.\n * @param inputSelectorArgs - List of arguments being passed to the input selectors.\n *\n * @see {@link https://reselect.js.org/api/development-only-stability-checks/#inputstabilitycheck `inputStabilityCheck`}\n *\n * @since 5.0.0\n * @internal\n */\nexport const runInputStabilityCheck = (\n  inputSelectorResultsObject: {\n    inputSelectorResults: unknown[]\n    inputSelectorResultsCopy: unknown[]\n  },\n  options: Required<\n    Pick<\n      CreateSelectorOptions<UnknownMemoizer, UnknownMemoizer>,\n      'memoize' | 'memoizeOptions'\n    >\n  >,\n  inputSelectorArgs: unknown[] | IArguments\n) => {\n  const { memoize, memoizeOptions } = options\n  const { inputSelectorResults, inputSelectorResultsCopy } =\n    inputSelectorResultsObject\n  const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions)\n  // if the memoize method thinks the parameters are equal, these *should* be the same reference\n  const areInputSelectorResultsEqual =\n    createAnEmptyObject.apply(null, inputSelectorResults) ===\n    createAnEmptyObject.apply(null, inputSelectorResultsCopy)\n  if (!areInputSelectorResultsEqual) {\n    let stack: string | undefined = undefined\n    try {\n      throw new Error()\n    } catch (e) {\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi, no-extra-semi\n      ;({ stack } = e as Error)\n    }\n    console.warn(\n      'An input selector returned a different result when passed same arguments.' +\n        '\\nThis means your output selector will likely run more frequently than intended.' +\n        '\\nAvoid returning a new reference inside your input selector, e.g.' +\n        '\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`',\n      {\n        arguments: inputSelectorArgs,\n        firstInputs: inputSelectorResults,\n        secondInputs: inputSelectorResultsCopy,\n        stack\n      }\n    )\n  }\n}\n","import type { DevModeChecks } from '../types'\n\n/**\n * Global configuration for development mode checks. This specifies the default\n * frequency at which each development mode check should be performed.\n *\n * @since 5.0.0\n * @internal\n */\nexport const globalDevModeChecks: DevModeChecks = {\n  inputStabilityCheck: 'once',\n  identityFunctionCheck: 'once'\n}\n\n/**\n * Overrides the development mode checks settings for all selectors.\n *\n * Reselect performs additional checks in development mode to help identify and\n * warn about potential issues in selector behavior. This function allows you to\n * customize the behavior of these checks across all selectors in your application.\n *\n * **Note**: This setting can still be overridden per selector inside `createSelector`'s `options` object.\n * See {@link https://github.com/reduxjs/reselect#2-per-selector-by-passing-an-identityfunctioncheck-option-directly-to-createselector per-selector-configuration}\n * and {@linkcode CreateSelectorOptions.identityFunctionCheck identityFunctionCheck} for more details.\n *\n * _The development mode checks do not run in production builds._\n *\n * @param devModeChecks - An object specifying the desired settings for development mode checks. You can provide partial overrides. Unspecified settings will retain their current values.\n *\n * @example\n * ```ts\n * import { setGlobalDevModeChecks } from 'reselect'\n * import { DevModeChecks } from '../types'\n *\n * // Run only the first time the selector is called. (default)\n * setGlobalDevModeChecks({ inputStabilityCheck: 'once' })\n *\n * // Run every time the selector is called.\n * setGlobalDevModeChecks({ inputStabilityCheck: 'always' })\n *\n * // Never run the input stability check.\n * setGlobalDevModeChecks({ inputStabilityCheck: 'never' })\n *\n * // Run only the first time the selector is called. (default)\n * setGlobalDevModeChecks({ identityFunctionCheck: 'once' })\n *\n * // Run every time the selector is called.\n * setGlobalDevModeChecks({ identityFunctionCheck: 'always' })\n *\n * // Never run the identity function check.\n * setGlobalDevModeChecks({ identityFunctionCheck: 'never' })\n * ```\n * @see {@link https://reselect.js.org/api/development-only-stability-checks Development-Only Stability Checks}\n * @see {@link https://reselect.js.org/api/development-only-stability-checks#1-globally-through-setglobaldevmodechecks global-configuration}\n *\n * @since 5.0.0\n * @public\n */\nexport const setGlobalDevModeChecks = (\n  devModeChecks: Partial<DevModeChecks>\n) => {\n  Object.assign(globalDevModeChecks, devModeChecks)\n}\n","import { runIdentityFunctionCheck } from './devModeChecks/identityFunctionCheck'\nimport { runInputStabilityCheck } from './devModeChecks/inputStabilityCheck'\nimport { globalDevModeChecks } from './devModeChecks/setGlobalDevModeChecks'\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nimport type {\n  DevModeChecks,\n  Selector,\n  SelectorArray,\n  DevModeChecksExecutionInfo\n} from './types'\n\nexport const NOT_FOUND = 'NOT_FOUND'\nexport type NOT_FOUND_TYPE = typeof NOT_FOUND\n\n/**\n * Assert that the provided value is a function. If the assertion fails,\n * a `TypeError` is thrown with an optional custom error message.\n *\n * @param func - The value to be checked.\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\n * @throws A `TypeError` if the assertion fails.\n */\nexport function assertIsFunction<FunctionType extends Function>(\n  func: unknown,\n  errorMessage = `expected a function, instead received ${typeof func}`\n): asserts func is FunctionType {\n  if (typeof func !== 'function') {\n    throw new TypeError(errorMessage)\n  }\n}\n\n/**\n * Assert that the provided value is an object. If the assertion fails,\n * a `TypeError` is thrown with an optional custom error message.\n *\n * @param object - The value to be checked.\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\n * @throws A `TypeError` if the assertion fails.\n */\nexport function assertIsObject<ObjectType extends Record<string, unknown>>(\n  object: unknown,\n  errorMessage = `expected an object, instead received ${typeof object}`\n): asserts object is ObjectType {\n  if (typeof object !== 'object') {\n    throw new TypeError(errorMessage)\n  }\n}\n\n/**\n * Assert that the provided array is an array of functions. If the assertion fails,\n * a `TypeError` is thrown with an optional custom error message.\n *\n * @param array - The array to be checked.\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\n * @throws A `TypeError` if the assertion fails.\n */\nexport function assertIsArrayOfFunctions<FunctionType extends Function>(\n  array: unknown[],\n  errorMessage = `expected all items to be functions, instead received the following types: `\n): asserts array is FunctionType[] {\n  if (\n    !array.every((item): item is FunctionType => typeof item === 'function')\n  ) {\n    const itemTypes = array\n      .map(item =>\n        typeof item === 'function'\n          ? `function ${item.name || 'unnamed'}()`\n          : typeof item\n      )\n      .join(', ')\n    throw new TypeError(`${errorMessage}[${itemTypes}]`)\n  }\n}\n\n/**\n * Ensure that the input is an array. If it's already an array, it's returned as is.\n * If it's not an array, it will be wrapped in a new array.\n *\n * @param item - The item to be checked.\n * @returns An array containing the input item. If the input is already an array, it's returned without modification.\n */\nexport const ensureIsArray = (item: unknown) => {\n  return Array.isArray(item) ? item : [item]\n}\n\n/**\n * Extracts the \"dependencies\" / \"input selectors\" from the arguments of `createSelector`.\n *\n * @param createSelectorArgs - Arguments passed to `createSelector` as an array.\n * @returns An array of \"input selectors\" / \"dependencies\".\n * @throws A `TypeError` if any of the input selectors is not function.\n */\nexport function getDependencies(createSelectorArgs: unknown[]) {\n  const dependencies = Array.isArray(createSelectorArgs[0])\n    ? createSelectorArgs[0]\n    : createSelectorArgs\n\n  assertIsArrayOfFunctions<Selector>(\n    dependencies,\n    `createSelector expects all input-selectors to be functions, but received the following types: `\n  )\n\n  return dependencies as SelectorArray\n}\n\n/**\n * Runs each input selector and returns their collective results as an array.\n *\n * @param dependencies - An array of \"dependencies\" or \"input selectors\".\n * @param inputSelectorArgs - An array of arguments being passed to the input selectors.\n * @returns An array of input selector results.\n */\nexport function collectInputSelectorResults(\n  dependencies: SelectorArray,\n  inputSelectorArgs: unknown[] | IArguments\n) {\n  const inputSelectorResults = []\n  const { length } = dependencies\n  for (let i = 0; i < length; i++) {\n    // @ts-ignore\n    // apply arguments instead of spreading and mutate a local list of params for performance.\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs))\n  }\n  return inputSelectorResults\n}\n\n/**\n * Retrieves execution information for development mode checks.\n *\n * @param devModeChecks - Custom Settings for development mode checks. These settings will override the global defaults.\n * @param firstRun - Indicates whether it is the first time the selector has run.\n * @returns  An object containing the execution information for each development mode check.\n */\nexport const getDevModeChecksExecutionInfo = (\n  firstRun: boolean,\n  devModeChecks: Partial<DevModeChecks>\n) => {\n  const { identityFunctionCheck, inputStabilityCheck } = {\n    ...globalDevModeChecks,\n    ...devModeChecks\n  }\n  return {\n    identityFunctionCheck: {\n      shouldRun:\n        identityFunctionCheck === 'always' ||\n        (identityFunctionCheck === 'once' && firstRun),\n      run: runIdentityFunctionCheck\n    },\n    inputStabilityCheck: {\n      shouldRun:\n        inputStabilityCheck === 'always' ||\n        (inputStabilityCheck === 'once' && firstRun),\n      run: runInputStabilityCheck\n    }\n  } satisfies DevModeChecksExecutionInfo\n}\n","// Original autotracking implementation source:\n// - https://gist.github.com/pzuraq/79bf862e0f8cd9521b79c4b6eccdc4f9\n// Additional references:\n// - https://www.pzuraq.com/blog/how-autotracking-works\n// - https://v5.chriskrycho.com/journal/autotracking-elegant-dx-via-cutting-edge-cs/\nimport type { EqualityFn } from '../types'\nimport { assertIsFunction } from '../utils'\n\n// The global revision clock. Every time state changes, the clock increments.\nexport let $REVISION = 0\n\n// The current dependency tracker. Whenever we compute a cache, we create a Set\n// to track any dependencies that are used while computing. If no cache is\n// computing, then the tracker is null.\nlet CURRENT_TRACKER: Set<Cell<any> | TrackingCache> | null = null\n\n// Storage represents a root value in the system - the actual state of our app.\nexport class Cell<T> {\n  revision = $REVISION\n\n  _value: T\n  _lastValue: T\n  _isEqual: EqualityFn = tripleEq\n\n  constructor(initialValue: T, isEqual: EqualityFn = tripleEq) {\n    this._value = this._lastValue = initialValue\n    this._isEqual = isEqual\n  }\n\n  // Whenever a storage value is read, it'll add itself to the current tracker if\n  // one exists, entangling its state with that cache.\n  get value() {\n    CURRENT_TRACKER?.add(this)\n\n    return this._value\n  }\n\n  // Whenever a storage value is updated, we bump the global revision clock,\n  // assign the revision for this storage to the new value, _and_ we schedule a\n  // rerender. This is important, and it's what makes autotracking  _pull_\n  // based. We don't actively tell the caches which depend on the storage that\n  // anything has happened. Instead, we recompute the caches when needed.\n  set value(newValue) {\n    if (this.value === newValue) return\n\n    this._value = newValue\n    this.revision = ++$REVISION\n  }\n}\n\nfunction tripleEq(a: unknown, b: unknown) {\n  return a === b\n}\n\n// Caches represent derived state in the system. They are ultimately functions\n// that are memoized based on what state they use to produce their output,\n// meaning they will only rerun IFF a storage value that could affect the output\n// has changed. Otherwise, they'll return the cached value.\nexport class TrackingCache {\n  _cachedValue: any\n  _cachedRevision = -1\n  _deps: any[] = []\n  hits = 0\n\n  fn: () => any\n\n  constructor(fn: () => any) {\n    this.fn = fn\n  }\n\n  clear() {\n    this._cachedValue = undefined\n    this._cachedRevision = -1\n    this._deps = []\n    this.hits = 0\n  }\n\n  get value() {\n    // When getting the value for a Cache, first we check all the dependencies of\n    // the cache to see what their current revision is. If the current revision is\n    // greater than the cached revision, then something has changed.\n    if (this.revision > this._cachedRevision) {\n      const { fn } = this\n\n      // We create a new dependency tracker for this cache. As the cache runs\n      // its function, any Storage or Cache instances which are used while\n      // computing will be added to this tracker. In the end, it will be the\n      // full list of dependencies that this Cache depends on.\n      const currentTracker = new Set<Cell<any>>()\n      const prevTracker = CURRENT_TRACKER\n\n      CURRENT_TRACKER = currentTracker\n\n      // try {\n      this._cachedValue = fn()\n      // } finally {\n      CURRENT_TRACKER = prevTracker\n      this.hits++\n      this._deps = Array.from(currentTracker)\n\n      // Set the cached revision. This is the current clock count of all the\n      // dependencies. If any dependency changes, this number will be less\n      // than the new revision.\n      this._cachedRevision = this.revision\n      // }\n    }\n\n    // If there is a current tracker, it means another Cache is computing and\n    // using this one, so we add this one to the tracker.\n    CURRENT_TRACKER?.add(this)\n\n    // Always return the cached value.\n    return this._cachedValue\n  }\n\n  get revision() {\n    // The current revision is the max of all the dependencies' revisions.\n    return Math.max(...this._deps.map(d => d.revision), 0)\n  }\n}\n\nexport function getValue<T>(cell: Cell<T>): T {\n  if (!(cell instanceof Cell)) {\n    console.warn('Not a valid cell! ', cell)\n  }\n\n  return cell.value\n}\n\ntype CellValue<T extends Cell<unknown>> = T extends Cell<infer U> ? U : never\n\nexport function setValue<T extends Cell<unknown>>(\n  storage: T,\n  value: CellValue<T>\n): void {\n  if (!(storage instanceof Cell)) {\n    throw new TypeError(\n      'setValue must be passed a tracked store created with `createStorage`.'\n    )\n  }\n\n  storage.value = storage._lastValue = value\n}\n\nexport function createCell<T = unknown>(\n  initialValue: T,\n  isEqual: EqualityFn = tripleEq\n): Cell<T> {\n  return new Cell(initialValue, isEqual)\n}\n\nexport function createCache<T = unknown>(fn: () => T): TrackingCache {\n  assertIsFunction(\n    fn,\n    'the first parameter to `createCache` must be a function'\n  )\n\n  return new TrackingCache(fn)\n}\n","import type { Cell } from './autotracking'\nimport {\n  getValue as consumeTag,\n  createCell as createStorage,\n  setValue\n} from './autotracking'\n\nexport type Tag = Cell<unknown>\n\nconst neverEq = (a: any, b: any): boolean => false\n\nexport function createTag(): Tag {\n  return createStorage(null, neverEq)\n}\nexport { consumeTag }\nexport function dirtyTag(tag: Tag, value: any): void {\n  setValue(tag, value)\n}\n\nexport interface Node<\n  T extends Array<unknown> | Record<string, unknown> =\n    | Array<unknown>\n    | Record<string, unknown>\n> {\n  collectionTag: Tag | null\n  tag: Tag | null\n  tags: Record<string, Tag>\n  children: Record<string, Node>\n  proxy: T\n  value: T\n  id: number\n}\n\nexport const consumeCollection = (node: Node): void => {\n  let tag = node.collectionTag\n\n  if (tag === null) {\n    tag = node.collectionTag = createTag()\n  }\n\n  consumeTag(tag)\n}\n\nexport const dirtyCollection = (node: Node): void => {\n  const tag = node.collectionTag\n\n  if (tag !== null) {\n    dirtyTag(tag, null)\n  }\n}\n","// Original source:\n// - https://github.com/simonihmig/tracked-redux/blob/master/packages/tracked-redux/src/-private/proxy.ts\n\nimport type { Node, Tag } from './tracking'\nimport {\n  consumeCollection,\n  consumeTag,\n  createTag,\n  dirtyCollection,\n  dirtyTag\n} from './tracking'\n\nexport const REDUX_PROXY_LABEL = Symbol()\n\nlet nextId = 0\n\nconst proto = Object.getPrototypeOf({})\n\nclass ObjectTreeNode<T extends Record<string, unknown>> implements Node<T> {\n  proxy: T = new Proxy(this, objectProxyHandler) as unknown as T\n  tag = createTag()\n  tags = {} as Record<string, Tag>\n  children = {} as Record<string, Node>\n  collectionTag = null\n  id = nextId++\n\n  constructor(public value: T) {\n    this.value = value\n    this.tag.value = value\n  }\n}\n\nconst objectProxyHandler = {\n  get(node: Node, key: string | symbol): unknown {\n    function calculateResult() {\n      const { value } = node\n\n      const childValue = Reflect.get(value, key)\n\n      if (typeof key === 'symbol') {\n        return childValue\n      }\n\n      if (key in proto) {\n        return childValue\n      }\n\n      if (typeof childValue === 'object' && childValue !== null) {\n        let childNode = node.children[key]\n\n        if (childNode === undefined) {\n          childNode = node.children[key] = createNode(childValue)\n        }\n\n        if (childNode.tag) {\n          consumeTag(childNode.tag)\n        }\n\n        return childNode.proxy\n      } else {\n        let tag = node.tags[key]\n\n        if (tag === undefined) {\n          tag = node.tags[key] = createTag()\n          tag.value = childValue\n        }\n\n        consumeTag(tag)\n\n        return childValue\n      }\n    }\n    const res = calculateResult()\n    return res\n  },\n\n  ownKeys(node: Node): ArrayLike<string | symbol> {\n    consumeCollection(node)\n    return Reflect.ownKeys(node.value)\n  },\n\n  getOwnPropertyDescriptor(\n    node: Node,\n    prop: string | symbol\n  ): PropertyDescriptor | undefined {\n    return Reflect.getOwnPropertyDescriptor(node.value, prop)\n  },\n\n  has(node: Node, prop: string | symbol): boolean {\n    return Reflect.has(node.value, prop)\n  }\n}\n\nclass ArrayTreeNode<T extends Array<unknown>> implements Node<T> {\n  proxy: T = new Proxy([this], arrayProxyHandler) as unknown as T\n  tag = createTag()\n  tags = {}\n  children = {}\n  collectionTag = null\n  id = nextId++\n\n  constructor(public value: T) {\n    this.value = value\n    this.tag.value = value\n  }\n}\n\nconst arrayProxyHandler = {\n  get([node]: [Node], key: string | symbol): unknown {\n    if (key === 'length') {\n      consumeCollection(node)\n    }\n\n    return objectProxyHandler.get(node, key)\n  },\n\n  ownKeys([node]: [Node]): ArrayLike<string | symbol> {\n    return objectProxyHandler.ownKeys(node)\n  },\n\n  getOwnPropertyDescriptor(\n    [node]: [Node],\n    prop: string | symbol\n  ): PropertyDescriptor | undefined {\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop)\n  },\n\n  has([node]: [Node], prop: string | symbol): boolean {\n    return objectProxyHandler.has(node, prop)\n  }\n}\n\nexport function createNode<T extends Array<unknown> | Record<string, unknown>>(\n  value: T\n): Node<T> {\n  if (Array.isArray(value)) {\n    return new ArrayTreeNode(value)\n  }\n\n  return new ObjectTreeNode(value) as Node<T>\n}\n\nconst keysMap = new WeakMap<\n  Array<unknown> | Record<string, unknown>,\n  Set<string>\n>()\n\nexport function updateNode<T extends Array<unknown> | Record<string, unknown>>(\n  node: Node<T>,\n  newValue: T\n): void {\n  const { value, tags, children } = node\n\n  node.value = newValue\n\n  if (\n    Array.isArray(value) &&\n    Array.isArray(newValue) &&\n    value.length !== newValue.length\n  ) {\n    dirtyCollection(node)\n  } else {\n    if (value !== newValue) {\n      let oldKeysSize = 0\n      let newKeysSize = 0\n      let anyKeysAdded = false\n\n      for (const _key in value) {\n        oldKeysSize++\n      }\n\n      for (const key in newValue) {\n        newKeysSize++\n        if (!(key in value)) {\n          anyKeysAdded = true\n          break\n        }\n      }\n\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize\n\n      if (isDifferent) {\n        dirtyCollection(node)\n      }\n    }\n  }\n\n  for (const key in tags) {\n    const childValue = (value as Record<string, unknown>)[key]\n    const newChildValue = (newValue as Record<string, unknown>)[key]\n\n    if (childValue !== newChildValue) {\n      dirtyCollection(node)\n      dirtyTag(tags[key], newChildValue)\n    }\n\n    if (typeof newChildValue === 'object' && newChildValue !== null) {\n      delete tags[key]\n    }\n  }\n\n  for (const key in children) {\n    const childNode = children[key]\n    const newChildValue = (newValue as Record<string, unknown>)[key]\n\n    const childValue = childNode.value\n\n    if (childValue === newChildValue) {\n      continue\n    } else if (typeof newChildValue === 'object' && newChildValue !== null) {\n      updateNode(childNode, newChildValue as Record<string, unknown>)\n    } else {\n      deleteNode(childNode)\n      delete children[key]\n    }\n  }\n}\n\nfunction deleteNode(node: Node): void {\n  if (node.tag) {\n    dirtyTag(node.tag, null)\n  }\n  dirtyCollection(node)\n  for (const key in node.tags) {\n    dirtyTag(node.tags[key], null)\n  }\n  for (const key in node.children) {\n    deleteNode(node.children[key])\n  }\n}\n","import type {\n  AnyFunction,\n  DefaultMemoizeFields,\n  EqualityFn,\n  Simplify\n} from './types'\n\nimport type { NOT_FOUND_TYPE } from './utils'\nimport { NOT_FOUND } from './utils'\n\n// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\n\ninterface Entry {\n  key: unknown\n  value: unknown\n}\n\ninterface Cache {\n  get(key: unknown): unknown | NOT_FOUND_TYPE\n  put(key: unknown, value: unknown): void\n  getEntries(): Entry[]\n  clear(): void\n}\n\nfunction createSingletonCache(equals: EqualityFn): Cache {\n  let entry: Entry | undefined\n  return {\n    get(key: unknown) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value\n      }\n\n      return NOT_FOUND\n    },\n\n    put(key: unknown, value: unknown) {\n      entry = { key, value }\n    },\n\n    getEntries() {\n      return entry ? [entry] : []\n    },\n\n    clear() {\n      entry = undefined\n    }\n  }\n}\n\nfunction createLruCache(maxSize: number, equals: EqualityFn): Cache {\n  let entries: Entry[] = []\n\n  function get(key: unknown) {\n    const cacheIndex = entries.findIndex(entry => equals(key, entry.key))\n\n    // We found a cached entry\n    if (cacheIndex > -1) {\n      const entry = entries[cacheIndex]\n\n      // Cached entry not at top of cache, move it to the top\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1)\n        entries.unshift(entry)\n      }\n\n      return entry.value\n    }\n\n    // No entry found in cache, return sentinel\n    return NOT_FOUND\n  }\n\n  function put(key: unknown, value: unknown) {\n    if (get(key) === NOT_FOUND) {\n      // TODO Is unshift slow?\n      entries.unshift({ key, value })\n      if (entries.length > maxSize) {\n        entries.pop()\n      }\n    }\n  }\n\n  function getEntries() {\n    return entries\n  }\n\n  function clear() {\n    entries = []\n  }\n\n  return { get, put, getEntries, clear }\n}\n\n/**\n * Runs a simple reference equality check.\n * What {@linkcode lruMemoize lruMemoize} uses by default.\n *\n * **Note**: This function was previously known as `defaultEqualityCheck`.\n *\n * @public\n */\nexport const referenceEqualityCheck: EqualityFn = (a, b) => a === b\n\nexport function createCacheKeyComparator(equalityCheck: EqualityFn) {\n  return function areArgumentsShallowlyEqual(\n    prev: unknown[] | IArguments | null,\n    next: unknown[] | IArguments | null\n  ): boolean {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false\n    }\n\n    // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n    const { length } = prev\n    for (let i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n/**\n * Options for configuring the behavior of a function memoized with\n * LRU (Least Recently Used) caching.\n *\n * @template Result - The type of the return value of the memoized function.\n *\n * @public\n */\nexport interface LruMemoizeOptions<Result = any> {\n  /**\n   * Function used to compare the individual arguments of the\n   * provided calculation function.\n   *\n   * @default referenceEqualityCheck\n   */\n  equalityCheck?: EqualityFn\n\n  /**\n   * If provided, used to compare a newly generated output value against\n   * previous values in the cache. If a match is found,\n   * the old value is returned. This addresses the common\n   * ```ts\n   * todos.map(todo => todo.id)\n   * ```\n   * use case, where an update to another field in the original data causes\n   * a recalculation due to changed references, but the output is still\n   * effectively the same.\n   *\n   * @since 4.1.0\n   */\n  resultEqualityCheck?: EqualityFn<Result>\n\n  /**\n   * The maximum size of the cache used by the selector.\n   * A size greater than 1 means the selector will use an\n   * LRU (Least Recently Used) cache, allowing for the caching of multiple\n   * results based on different sets of arguments.\n   *\n   * @default 1\n   */\n  maxSize?: number\n}\n\n/**\n * Creates a memoized version of a function with an optional\n * LRU (Least Recently Used) cache. The memoized function uses a cache to\n * store computed values. Depending on the `maxSize` option, it will use\n * either a singleton cache (for a single entry) or an\n * LRU cache (for multiple entries).\n *\n * **Note**: This function was previously known as `defaultMemoize`.\n *\n * @param func - The function to be memoized.\n * @param equalityCheckOrOptions - Either an equality check function or an options object.\n * @returns A memoized function with a `.clearCache()` method attached.\n *\n * @template Func - The type of the function that is memoized.\n *\n * @see {@link https://reselect.js.org/api/lruMemoize `lruMemoize`}\n *\n * @public\n */\nexport function lruMemoize<Func extends AnyFunction>(\n  func: Func,\n  equalityCheckOrOptions?: EqualityFn | LruMemoizeOptions<ReturnType<Func>>\n) {\n  const providedOptions =\n    typeof equalityCheckOrOptions === 'object'\n      ? equalityCheckOrOptions\n      : { equalityCheck: equalityCheckOrOptions }\n\n  const {\n    equalityCheck = referenceEqualityCheck,\n    maxSize = 1,\n    resultEqualityCheck\n  } = providedOptions\n\n  const comparator = createCacheKeyComparator(equalityCheck)\n\n  let resultsCount = 0\n\n  const cache =\n    maxSize === 1\n      ? createSingletonCache(comparator)\n      : createLruCache(maxSize, comparator)\n\n  function memoized() {\n    let value = cache.get(arguments) as ReturnType<Func>\n    if (value === NOT_FOUND) {\n      // apply arguments instead of spreading for performance.\n      // @ts-ignore\n      value = func.apply(null, arguments) as ReturnType<Func>\n      resultsCount++\n\n      if (resultEqualityCheck) {\n        const entries = cache.getEntries()\n        const matchingEntry = entries.find(entry =>\n          resultEqualityCheck(entry.value as ReturnType<Func>, value)\n        )\n\n        if (matchingEntry) {\n          value = matchingEntry.value as ReturnType<Func>\n          resultsCount !== 0 && resultsCount--\n        }\n      }\n\n      cache.put(arguments, value)\n    }\n    return value\n  }\n\n  memoized.clearCache = () => {\n    cache.clear()\n    memoized.resetResultsCount()\n  }\n\n  memoized.resultsCount = () => resultsCount\n\n  memoized.resetResultsCount = () => {\n    resultsCount = 0\n  }\n\n  return memoized as Func & Simplify<DefaultMemoizeFields>\n}\n","import { createNode, updateNode } from './proxy'\nimport type { Node } from './tracking'\n\nimport { createCacheKeyComparator, referenceEqualityCheck } from '../lruMemoize'\nimport type { AnyFunction, DefaultMemoizeFields, Simplify } from '../types'\nimport { createCache } from './autotracking'\n\n/**\n * Uses an \"auto-tracking\" approach inspired by the work of the Ember Glimmer team.\n * It uses a Proxy to wrap arguments and track accesses to nested fields\n * in your selector on first read. Later, when the selector is called with\n * new arguments, it identifies which accessed fields have changed and\n * only recalculates the result if one or more of those accessed fields have changed.\n * This allows it to be more precise than the shallow equality checks in `lruMemoize`.\n *\n * __Design Tradeoffs for `autotrackMemoize`:__\n * - Pros:\n *    - It is likely to avoid excess calculations and recalculate fewer times than `lruMemoize` will,\n *    which may also result in fewer component re-renders.\n * - Cons:\n *    - It only has a cache size of 1.\n *    - It is slower than `lruMemoize`, because it has to do more work. (How much slower is dependent on the number of accessed fields in a selector, number of calls, frequency of input changes, etc)\n *    - It can have some unexpected behavior. Because it tracks nested field accesses,\n *    cases where you don't access a field will not recalculate properly.\n *    For example, a badly-written selector like:\n *      ```ts\n *      createSelector([state => state.todos], todos => todos)\n *      ```\n *      that just immediately returns the extracted value will never update, because it doesn't see any field accesses to check.\n *\n * __Use Cases for `autotrackMemoize`:__\n * - It is likely best used for cases where you need to access specific nested fields\n * in data, and avoid recalculating if other fields in the same data objects are immutably updated.\n *\n * @param func - The function to be memoized.\n * @returns A memoized function with a `.clearCache()` method attached.\n *\n * @example\n * <caption>Using `createSelector`</caption>\n * ```ts\n * import { unstable_autotrackMemoize as autotrackMemoize, createSelector } from 'reselect'\n *\n * const selectTodoIds = createSelector(\n *   [(state: RootState) => state.todos],\n *   (todos) => todos.map(todo => todo.id),\n *   { memoize: autotrackMemoize }\n * )\n * ```\n *\n * @example\n * <caption>Using `createSelectorCreator`</caption>\n * ```ts\n * import { unstable_autotrackMemoize as autotrackMemoize, createSelectorCreator } from 'reselect'\n *\n * const createSelectorAutotrack = createSelectorCreator({ memoize: autotrackMemoize })\n *\n * const selectTodoIds = createSelectorAutotrack(\n *   [(state: RootState) => state.todos],\n *   (todos) => todos.map(todo => todo.id)\n * )\n * ```\n *\n * @template Func - The type of the function that is memoized.\n *\n * @see {@link https://reselect.js.org/api/unstable_autotrackMemoize autotrackMemoize}\n *\n * @since 5.0.0\n * @public\n * @experimental\n */\nexport function autotrackMemoize<Func extends AnyFunction>(func: Func) {\n  // we reference arguments instead of spreading them for performance reasons\n\n  const node: Node<Record<string, unknown>> = createNode(\n    [] as unknown as Record<string, unknown>\n  )\n\n  let lastArgs: IArguments | null = null\n\n  const shallowEqual = createCacheKeyComparator(referenceEqualityCheck)\n\n  const cache = createCache(() => {\n    const res = func.apply(null, node.proxy as unknown as any[])\n    return res\n  })\n\n  function memoized() {\n    if (!shallowEqual(lastArgs, arguments)) {\n      updateNode(node, arguments as unknown as Record<string, unknown>)\n      lastArgs = arguments\n    }\n    return cache.value\n  }\n\n  memoized.clearCache = () => {\n    return cache.clear()\n  }\n\n  return memoized as Func & Simplify<DefaultMemoizeFields>\n}\n","// Original source:\n// - https://github.com/facebook/react/blob/0b974418c9a56f6c560298560265dcf4b65784bc/packages/react/src/ReactCache.js\n\nimport type {\n  AnyFunction,\n  DefaultMemoizeFields,\n  EqualityFn,\n  Simplify\n} from './types'\n\nclass StrongRef<T> {\n  constructor(private value: T) {}\n  deref() {\n    return this.value\n  }\n}\n\nconst Ref =\n  typeof WeakRef !== 'undefined'\n    ? WeakRef\n    : (StrongRef as unknown as typeof WeakRef)\n\nconst UNTERMINATED = 0\nconst TERMINATED = 1\n\ninterface UnterminatedCacheNode<T> {\n  /**\n   * Status, represents whether the cached computation returned a value or threw an error.\n   */\n  s: 0\n  /**\n   * Value, either the cached result or an error, depending on status.\n   */\n  v: void\n  /**\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\n   */\n  o: null | WeakMap<Function | Object, CacheNode<T>>\n  /**\n   * Primitive cache, a regular Map where primitive arguments are stored.\n   */\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\n}\n\ninterface TerminatedCacheNode<T> {\n  /**\n   * Status, represents whether the cached computation returned a value or threw an error.\n   */\n  s: 1\n  /**\n   * Value, either the cached result or an error, depending on status.\n   */\n  v: T\n  /**\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\n   */\n  o: null | WeakMap<Function | Object, CacheNode<T>>\n  /**\n   * Primitive cache, a regular `Map` where primitive arguments are stored.\n   */\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\n}\n\ntype CacheNode<T> = TerminatedCacheNode<T> | UnterminatedCacheNode<T>\n\nfunction createCacheNode<T>(): CacheNode<T> {\n  return {\n    s: UNTERMINATED,\n    v: undefined,\n    o: null,\n    p: null\n  }\n}\n\n/**\n * Configuration options for a memoization function utilizing `WeakMap` for\n * its caching mechanism.\n *\n * @template Result - The type of the return value of the memoized function.\n *\n * @since 5.0.0\n * @public\n */\nexport interface WeakMapMemoizeOptions<Result = any> {\n  /**\n   * If provided, used to compare a newly generated output value against previous values in the cache.\n   * If a match is found, the old value is returned. This addresses the common\n   * ```ts\n   * todos.map(todo => todo.id)\n   * ```\n   * use case, where an update to another field in the original data causes a recalculation\n   * due to changed references, but the output is still effectively the same.\n   *\n   * @since 5.0.0\n   */\n  resultEqualityCheck?: EqualityFn<Result>\n}\n\n/**\n * Creates a tree of `WeakMap`-based cache nodes based on the identity of the\n * arguments it's been called with (in this case, the extracted values from your input selectors).\n * This allows `weakMapMemoize` to have an effectively infinite cache size.\n * Cache results will be kept in memory as long as references to the arguments still exist,\n * and then cleared out as the arguments are garbage-collected.\n *\n * __Design Tradeoffs for `weakMapMemoize`:__\n * - Pros:\n *   - It has an effectively infinite cache size, but you have no control over\n *   how long values are kept in cache as it's based on garbage collection and `WeakMap`s.\n * - Cons:\n *   - There's currently no way to alter the argument comparisons.\n *   They're based on strict reference equality.\n *   - It's roughly the same speed as `lruMemoize`, although likely a fraction slower.\n *\n * __Use Cases for `weakMapMemoize`:__\n * - This memoizer is likely best used for cases where you need to call the\n * same selector instance with many different arguments, such as a single\n * selector instance that is used in a list item component and called with\n * item IDs like:\n *   ```ts\n *   useSelector(state => selectSomeData(state, props.category))\n *   ```\n * @param func - The function to be memoized.\n * @returns A memoized function with a `.clearCache()` method attached.\n *\n * @example\n * <caption>Using `createSelector`</caption>\n * ```ts\n * import { createSelector, weakMapMemoize } from 'reselect'\n *\n * interface RootState {\n *   items: { id: number; category: string; name: string }[]\n * }\n *\n * const selectItemsByCategory = createSelector(\n *   [\n *     (state: RootState) => state.items,\n *     (state: RootState, category: string) => category\n *   ],\n *   (items, category) => items.filter(item => item.category === category),\n *   {\n *     memoize: weakMapMemoize,\n *     argsMemoize: weakMapMemoize\n *   }\n * )\n * ```\n *\n * @example\n * <caption>Using `createSelectorCreator`</caption>\n * ```ts\n * import { createSelectorCreator, weakMapMemoize } from 'reselect'\n *\n * const createSelectorWeakMap = createSelectorCreator({ memoize: weakMapMemoize, argsMemoize: weakMapMemoize })\n *\n * const selectItemsByCategory = createSelectorWeakMap(\n *   [\n *     (state: RootState) => state.items,\n *     (state: RootState, category: string) => category\n *   ],\n *   (items, category) => items.filter(item => item.category === category)\n * )\n * ```\n *\n * @template Func - The type of the function that is memoized.\n *\n * @see {@link https://reselect.js.org/api/weakMapMemoize `weakMapMemoize`}\n *\n * @since 5.0.0\n * @public\n * @experimental\n */\nexport function weakMapMemoize<Func extends AnyFunction>(\n  func: Func,\n  options: WeakMapMemoizeOptions<ReturnType<Func>> = {}\n) {\n  let fnNode = createCacheNode()\n  const { resultEqualityCheck } = options\n\n  let lastResult: WeakRef<object> | undefined\n\n  let resultsCount = 0\n\n  function memoized() {\n    let cacheNode = fnNode\n    const { length } = arguments\n    for (let i = 0, l = length; i < l; i++) {\n      const arg = arguments[i]\n      if (\n        typeof arg === 'function' ||\n        (typeof arg === 'object' && arg !== null)\n      ) {\n        // Objects go into a WeakMap\n        let objectCache = cacheNode.o\n        if (objectCache === null) {\n          cacheNode.o = objectCache = new WeakMap()\n        }\n        const objectNode = objectCache.get(arg)\n        if (objectNode === undefined) {\n          cacheNode = createCacheNode()\n          objectCache.set(arg, cacheNode)\n        } else {\n          cacheNode = objectNode\n        }\n      } else {\n        // Primitives go into a regular Map\n        let primitiveCache = cacheNode.p\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = new Map()\n        }\n        const primitiveNode = primitiveCache.get(arg)\n        if (primitiveNode === undefined) {\n          cacheNode = createCacheNode()\n          primitiveCache.set(arg, cacheNode)\n        } else {\n          cacheNode = primitiveNode\n        }\n      }\n    }\n\n    const terminatedNode = cacheNode as unknown as TerminatedCacheNode<any>\n\n    let result\n\n    if (cacheNode.s === TERMINATED) {\n      result = cacheNode.v\n    } else {\n      // Allow errors to propagate\n      result = func.apply(null, arguments as unknown as any[])\n      resultsCount++\n    }\n\n    terminatedNode.s = TERMINATED\n\n    if (resultEqualityCheck) {\n      const lastResultValue = lastResult?.deref?.() ?? lastResult\n      if (\n        lastResultValue != null &&\n        resultEqualityCheck(lastResultValue as ReturnType<Func>, result)\n      ) {\n        result = lastResultValue\n        resultsCount !== 0 && resultsCount--\n      }\n\n      const needsWeakRef =\n        (typeof result === 'object' && result !== null) ||\n        typeof result === 'function'\n      lastResult = needsWeakRef ? new Ref(result) : result\n    }\n    terminatedNode.v = result\n    return result\n  }\n\n  memoized.clearCache = () => {\n    fnNode = createCacheNode()\n    memoized.resetResultsCount()\n  }\n\n  memoized.resultsCount = () => resultsCount\n\n  memoized.resetResultsCount = () => {\n    resultsCount = 0\n  }\n\n  return memoized as Func & Simplify<DefaultMemoizeFields>\n}\n","import { weakMapMemoize } from './weakMapMemoize'\n\nimport type {\n  Combiner,\n  CreateSelectorOptions,\n  DropFirstParameter,\n  ExtractMemoizerFields,\n  GetParamsFromSelectors,\n  GetStateFromSelectors,\n  InterruptRecursion,\n  OutputSelector,\n  Selector,\n  SelectorArray,\n  SetRequired,\n  Simplify,\n  UnknownMemoizer\n} from './types'\n\nimport {\n  assertIsFunction,\n  collectInputSelectorResults,\n  ensureIsArray,\n  getDependencies,\n  getDevModeChecksExecutionInfo\n} from './utils'\n\n/**\n * An instance of `createSelector`, customized with a given memoize implementation.\n *\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\n * @template StateType - The type of state that the selectors created with this selector creator will operate on.\n *\n * @public\n */\nexport interface CreateSelectorFunction<\n  MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\n  StateType = any\n> {\n  /**\n   * Creates a memoized selector function.\n   *\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments and a `combiner` function.\n   * @returns A memoized output selector.\n   *\n   * @template InputSelectors - The type of the input selectors as an array.\n   * @template Result - The return type of the `combiner` as well as the output selector.\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\n   *\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\n   */\n  <InputSelectors extends SelectorArray<StateType>, Result>(\n    ...createSelectorArgs: [\n      ...inputSelectors: InputSelectors,\n      combiner: Combiner<InputSelectors, Result>\n    ]\n  ): OutputSelector<\n    InputSelectors,\n    Result,\n    MemoizeFunction,\n    ArgsMemoizeFunction\n  > &\n    InterruptRecursion\n\n  /**\n   * Creates a memoized selector function.\n   *\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments, a `combiner` function and an `options` object.\n   * @returns A memoized output selector.\n   *\n   * @template InputSelectors - The type of the input selectors as an array.\n   * @template Result - The return type of the `combiner` as well as the output selector.\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\n   *\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\n   */\n  <\n    InputSelectors extends SelectorArray<StateType>,\n    Result,\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\n  >(\n    ...createSelectorArgs: [\n      ...inputSelectors: InputSelectors,\n      combiner: Combiner<InputSelectors, Result>,\n      createSelectorOptions: Simplify<\n        CreateSelectorOptions<\n          MemoizeFunction,\n          ArgsMemoizeFunction,\n          OverrideMemoizeFunction,\n          OverrideArgsMemoizeFunction\n        >\n      >\n    ]\n  ): OutputSelector<\n    InputSelectors,\n    Result,\n    OverrideMemoizeFunction,\n    OverrideArgsMemoizeFunction\n  > &\n    InterruptRecursion\n\n  /**\n   * Creates a memoized selector function.\n   *\n   * @param inputSelectors - An array of input selectors.\n   * @param combiner - A function that Combines the input selectors and returns an output selector. Otherwise known as the result function.\n   * @param createSelectorOptions - An optional options object that allows for further customization per selector.\n   * @returns A memoized output selector.\n   *\n   * @template InputSelectors - The type of the input selectors array.\n   * @template Result - The return type of the `combiner` as well as the output selector.\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\n   *\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\n   */\n  <\n    InputSelectors extends SelectorArray<StateType>,\n    Result,\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\n  >(\n    inputSelectors: [...InputSelectors],\n    combiner: Combiner<InputSelectors, Result>,\n    createSelectorOptions?: Simplify<\n      CreateSelectorOptions<\n        MemoizeFunction,\n        ArgsMemoizeFunction,\n        OverrideMemoizeFunction,\n        OverrideArgsMemoizeFunction\n      >\n    >\n  ): OutputSelector<\n    InputSelectors,\n    Result,\n    OverrideMemoizeFunction,\n    OverrideArgsMemoizeFunction\n  > &\n    InterruptRecursion\n\n  /**\n   * Creates a \"pre-typed\" version of {@linkcode createSelector createSelector}\n   * where the `state` type is predefined.\n   *\n   * This allows you to set the `state` type once, eliminating the need to\n   * specify it with every {@linkcode createSelector createSelector} call.\n   *\n   * @returns A pre-typed `createSelector` with the state type already defined.\n   *\n   * @example\n   * ```ts\n   * import { createSelector } from 'reselect'\n   *\n   * export interface RootState {\n   *   todos: { id: number; completed: boolean }[]\n   *   alerts: { id: number; read: boolean }[]\n   * }\n   *\n   * export const createAppSelector = createSelector.withTypes<RootState>()\n   *\n   * const selectTodoIds = createAppSelector(\n   *   [\n   *     // Type of `state` is set to `RootState`, no need to manually set the type\n   *     state => state.todos\n   *   ],\n   *   todos => todos.map(({ id }) => id)\n   * )\n   * ```\n   * @template OverrideStateType - The specific type of state used by all selectors created with this selector creator.\n   *\n   * @see {@link https://reselect.js.org/api/createselector#defining-a-pre-typed-createselector `createSelector.withTypes`}\n   *\n   * @since 5.1.0\n   */\n  withTypes: <OverrideStateType extends StateType>() => CreateSelectorFunction<\n    MemoizeFunction,\n    ArgsMemoizeFunction,\n    OverrideStateType\n  >\n}\n\n/**\n * Creates a selector creator function with the specified memoization function\n * and options for customizing memoization behavior.\n *\n * @param options - An options object containing the `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). It also provides additional options for customizing memoization. While the `memoize` property is mandatory, the rest are optional.\n * @returns A customized `createSelector` function.\n *\n * @example\n * ```ts\n * const customCreateSelector = createSelectorCreator({\n *   memoize: customMemoize, // Function to be used to memoize `resultFunc`\n *   memoizeOptions: [memoizeOption1, memoizeOption2], // Options passed to `customMemoize` as the second argument onwards\n *   argsMemoize: customArgsMemoize, // Function to be used to memoize the selector's arguments\n *   argsMemoizeOptions: [argsMemoizeOption1, argsMemoizeOption2] // Options passed to `customArgsMemoize` as the second argument onwards\n * })\n *\n * const customSelector = customCreateSelector(\n *   [inputSelector1, inputSelector2],\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\n * )\n *\n * customSelector(\n *   ...selectorArgs // Will be memoized by `customArgsMemoize`\n * )\n * ```\n *\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\n *\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-options-since-500 `createSelectorCreator`}\n *\n * @since 5.0.0\n * @public\n */\nexport function createSelectorCreator<\n  MemoizeFunction extends UnknownMemoizer,\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\n>(\n  options: Simplify<\n    SetRequired<\n      CreateSelectorOptions<\n        typeof weakMapMemoize,\n        typeof weakMapMemoize,\n        MemoizeFunction,\n        ArgsMemoizeFunction\n      >,\n      'memoize'\n    >\n  >\n): CreateSelectorFunction<MemoizeFunction, ArgsMemoizeFunction>\n\n/**\n * Creates a selector creator function with the specified memoization function\n * and options for customizing memoization behavior.\n *\n * @param memoize - The `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\n * @returns A customized `createSelector` function.\n *\n * @example\n * ```ts\n * const customCreateSelector = createSelectorCreator(customMemoize, // Function to be used to memoize `resultFunc`\n *   option1, // Will be passed as second argument to `customMemoize`\n *   option2, // Will be passed as third argument to `customMemoize`\n *   option3 // Will be passed as fourth argument to `customMemoize`\n * )\n *\n * const customSelector = customCreateSelector(\n *   [inputSelector1, inputSelector2],\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\n * )\n * ```\n *\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\n *\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-memoize-and-memoizeoptions `createSelectorCreator`}\n *\n * @public\n */\nexport function createSelectorCreator<MemoizeFunction extends UnknownMemoizer>(\n  memoize: MemoizeFunction,\n  ...memoizeOptionsFromArgs: DropFirstParameter<MemoizeFunction>\n): CreateSelectorFunction<MemoizeFunction>\n\n/**\n * Creates a selector creator function with the specified memoization\n * function and options for customizing memoization behavior.\n *\n * @param memoizeOrOptions - Either A `memoize` function or an `options` object containing the `memoize` function.\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\n * @returns A customized `createSelector` function.\n *\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\n * @template MemoizeOrOptions - The type of the first argument. It can either be a `memoize` function or an `options` object containing the `memoize` function.\n */\nexport function createSelectorCreator<\n  MemoizeFunction extends UnknownMemoizer,\n  ArgsMemoizeFunction extends UnknownMemoizer,\n  MemoizeOrOptions extends\n    | MemoizeFunction\n    | SetRequired<\n        CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\n        'memoize'\n      >\n>(\n  memoizeOrOptions: MemoizeOrOptions,\n  ...memoizeOptionsFromArgs: MemoizeOrOptions extends SetRequired<\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\n    'memoize'\n  >\n    ? never\n    : DropFirstParameter<MemoizeFunction>\n) {\n  /** options initially passed into `createSelectorCreator`. */\n  const createSelectorCreatorOptions: SetRequired<\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\n    'memoize'\n  > = typeof memoizeOrOptions === 'function'\n    ? {\n        memoize: memoizeOrOptions as MemoizeFunction,\n        memoizeOptions: memoizeOptionsFromArgs\n      }\n    : memoizeOrOptions\n\n  const createSelector = <\n    InputSelectors extends SelectorArray,\n    Result,\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\n  >(\n    ...createSelectorArgs: [\n      ...inputSelectors: [...InputSelectors],\n      combiner: Combiner<InputSelectors, Result>,\n      createSelectorOptions?: CreateSelectorOptions<\n        MemoizeFunction,\n        ArgsMemoizeFunction,\n        OverrideMemoizeFunction,\n        OverrideArgsMemoizeFunction\n      >\n    ]\n  ) => {\n    let recomputations = 0\n    let dependencyRecomputations = 0\n    let lastResult: Result\n\n    // Due to the intricacies of rest params, we can't do an optional arg after `...createSelectorArgs`.\n    // So, start by declaring the default value here.\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\n    let directlyPassedOptions: CreateSelectorOptions<\n      MemoizeFunction,\n      ArgsMemoizeFunction,\n      OverrideMemoizeFunction,\n      OverrideArgsMemoizeFunction\n    > = {}\n\n    // Normally, the result func or \"combiner\" is the last arg\n    let resultFunc = createSelectorArgs.pop() as\n      | Combiner<InputSelectors, Result>\n      | CreateSelectorOptions<\n          MemoizeFunction,\n          ArgsMemoizeFunction,\n          OverrideMemoizeFunction,\n          OverrideArgsMemoizeFunction\n        >\n\n    // If the result func is actually an _object_, assume it's our options object\n    if (typeof resultFunc === 'object') {\n      directlyPassedOptions = resultFunc\n      // and pop the real result func off\n      resultFunc = createSelectorArgs.pop() as Combiner<InputSelectors, Result>\n    }\n\n    assertIsFunction(\n      resultFunc,\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\n    )\n\n    // Determine which set of options we're using. Prefer options passed directly,\n    // but fall back to options given to `createSelectorCreator`.\n    const combinedOptions = {\n      ...createSelectorCreatorOptions,\n      ...directlyPassedOptions\n    }\n\n    const {\n      memoize,\n      memoizeOptions = [],\n      argsMemoize = weakMapMemoize,\n      argsMemoizeOptions = [],\n      devModeChecks = {}\n    } = combinedOptions\n\n    // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\n    // is an array. In most libs I've looked at, it's an equality function or options object.\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\n    // we wrap it in an array so we can apply it.\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions)\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions)\n    const dependencies = getDependencies(createSelectorArgs) as InputSelectors\n\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\n      recomputations++\n      // apply arguments instead of spreading for performance.\n      // @ts-ignore\n      return (resultFunc as Combiner<InputSelectors, Result>).apply(\n        null,\n        arguments\n      )\n    }, ...finalMemoizeOptions) as Combiner<InputSelectors, Result> &\n      ExtractMemoizerFields<OverrideMemoizeFunction>\n\n    let firstRun = true\n\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\n    const selector = argsMemoize(function dependenciesChecker() {\n      dependencyRecomputations++\n      /** Return values of input selectors which the `resultFunc` takes as arguments. */\n      const inputSelectorResults = collectInputSelectorResults(\n        dependencies,\n        arguments\n      )\n\n      // apply arguments instead of spreading for performance.\n      // @ts-ignore\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults)\n\n      if (process.env.NODE_ENV !== 'production') {\n        const { identityFunctionCheck, inputStabilityCheck } =\n          getDevModeChecksExecutionInfo(firstRun, devModeChecks)\n        if (identityFunctionCheck.shouldRun) {\n          identityFunctionCheck.run(\n            resultFunc as Combiner<InputSelectors, Result>,\n            inputSelectorResults,\n            lastResult\n          )\n        }\n\n        if (inputStabilityCheck.shouldRun) {\n          // make a second copy of the params, to check if we got the same results\n          const inputSelectorResultsCopy = collectInputSelectorResults(\n            dependencies,\n            arguments\n          )\n\n          inputStabilityCheck.run(\n            { inputSelectorResults, inputSelectorResultsCopy },\n            { memoize, memoizeOptions: finalMemoizeOptions },\n            arguments\n          )\n        }\n\n        if (firstRun) firstRun = false\n      }\n\n      return lastResult\n    }, ...finalArgsMemoizeOptions) as unknown as Selector<\n      GetStateFromSelectors<InputSelectors>,\n      Result,\n      GetParamsFromSelectors<InputSelectors>\n    > &\n      ExtractMemoizerFields<OverrideArgsMemoizeFunction>\n\n    return Object.assign(selector, {\n      resultFunc,\n      memoizedResultFunc,\n      dependencies,\n      dependencyRecomputations: () => dependencyRecomputations,\n      resetDependencyRecomputations: () => {\n        dependencyRecomputations = 0\n      },\n      lastResult: () => lastResult,\n      recomputations: () => recomputations,\n      resetRecomputations: () => {\n        recomputations = 0\n      },\n      memoize,\n      argsMemoize\n    }) as OutputSelector<\n      InputSelectors,\n      Result,\n      OverrideMemoizeFunction,\n      OverrideArgsMemoizeFunction\n    >\n  }\n\n  Object.assign(createSelector, {\n    withTypes: () => createSelector\n  })\n\n  return createSelector as CreateSelectorFunction<\n    MemoizeFunction,\n    ArgsMemoizeFunction\n  >\n}\n\n/**\n * Accepts one or more \"input selectors\" (either as separate arguments or a single array),\n * a single \"result function\" / \"combiner\", and an optional options object, and\n * generates a memoized selector function.\n *\n * @see {@link https://reselect.js.org/api/createSelector `createSelector`}\n *\n * @public\n */\nexport const createSelector =\n  /* #__PURE__ */ createSelectorCreator(weakMapMemoize)\n","import { createSelector } from './createSelectorCreator'\n\nimport type { CreateSelectorFunction } from './createSelectorCreator'\nimport type {\n  InterruptRecursion,\n  ObjectValuesToTuple,\n  OutputSelector,\n  Selector,\n  Simplify,\n  UnknownMemoizer\n} from './types'\nimport { assertIsObject } from './utils'\nimport type { weakMapMemoize } from './weakMapMemoize'\n\n/**\n * Represents a mapping of selectors to their return types.\n *\n * @template TObject - An object type where each property is a selector function.\n *\n * @public\n */\nexport type SelectorResultsMap<TObject extends SelectorsObject> = {\n  [Key in keyof TObject]: ReturnType<TObject[Key]>\n}\n\n/**\n * Represents a mapping of selectors for each key in a given root state.\n *\n * This type is a utility that takes a root state object type and\n * generates a corresponding set of selectors. Each selector is associated\n * with a key in the root state, allowing for the selection\n * of specific parts of the state.\n *\n * @template RootState - The type of the root state object.\n *\n * @since 5.0.0\n * @public\n */\nexport type RootStateSelectors<RootState = any> = {\n  [Key in keyof RootState]: Selector<RootState, RootState[Key], []>\n}\n\n/**\n * @deprecated Please use {@linkcode StructuredSelectorCreator.withTypes createStructuredSelector.withTypes<RootState>()} instead. This type will be removed in the future.\n * @template RootState - The type of the root state object.\n *\n * @since 5.0.0\n * @public\n */\nexport type TypedStructuredSelectorCreator<RootState = any> =\n  /**\n   * A convenience function that simplifies returning an object\n   * made up of selector results.\n   *\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\n   * @returns A memoized structured selector.\n   *\n   * @example\n   * <caption>Modern Use Case</caption>\n   * ```ts\n   * import { createSelector, createStructuredSelector } from 'reselect'\n   *\n   * interface RootState {\n   *   todos: {\n   *     id: number\n   *     completed: boolean\n   *     title: string\n   *     description: string\n   *   }[]\n   *   alerts: { id: number; read: boolean }[]\n   * }\n   *\n   * // This:\n   * const structuredSelector = createStructuredSelector(\n   *   {\n   *     todos: (state: RootState) => state.todos,\n   *     alerts: (state: RootState) => state.alerts,\n   *     todoById: (state: RootState, id: number) => state.todos[id]\n   *   },\n   *   createSelector\n   * )\n   *\n   * // Is essentially the same as this:\n   * const selector = createSelector(\n   *   [\n   *     (state: RootState) => state.todos,\n   *     (state: RootState) => state.alerts,\n   *     (state: RootState, id: number) => state.todos[id]\n   *   ],\n   *   (todos, alerts, todoById) => {\n   *     return {\n   *       todos,\n   *       alerts,\n   *       todoById\n   *     }\n   *   }\n   * )\n   * ```\n   *\n   * @example\n   * <caption>In your component:</caption>\n   * ```tsx\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\n   * import type { FC } from 'react'\n   * import { useSelector } from 'react-redux'\n   *\n   * interface Props {\n   *   id: number\n   * }\n   *\n   * const MyComponent: FC<Props> = ({ id }) => {\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\n   *     structuredSelector(state, id)\n   *   )\n   *\n   *   return (\n   *     <div>\n   *       Next to do is:\n   *       <h2>{todoById.title}</h2>\n   *       <p>Description: {todoById.description}</p>\n   *       <ul>\n   *         <h3>All other to dos:</h3>\n   *         {todos.map(todo => (\n   *           <li key={todo.id}>{todo.title}</li>\n   *         ))}\n   *       </ul>\n   *     </div>\n   *   )\n   * }\n   * ```\n   *\n   * @example\n   * <caption>Simple Use Case</caption>\n   * ```ts\n   * const selectA = state => state.a\n   * const selectB = state => state.b\n   *\n   * // The result function in the following selector\n   * // is simply building an object from the input selectors\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\n   *   a,\n   *   b\n   * }))\n   *\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\n   * ```\n   *\n   * @template InputSelectorsObject - The shape of the input selectors object.\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\n   *\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\n   */\n  <\n    InputSelectorsObject extends RootStateSelectors<RootState> = RootStateSelectors<RootState>,\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\n  >(\n    inputSelectorsObject: InputSelectorsObject,\n    selectorCreator?: CreateSelectorFunction<\n      MemoizeFunction,\n      ArgsMemoizeFunction\n    >\n  ) => OutputSelector<\n    ObjectValuesToTuple<InputSelectorsObject>,\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\n    MemoizeFunction,\n    ArgsMemoizeFunction\n  > &\n    InterruptRecursion\n\n/**\n * Represents an object where each property is a selector function.\n *\n * @template StateType - The type of state that all the selectors operate on.\n *\n * @public\n */\nexport type SelectorsObject<StateType = any> = Record<\n  string,\n  Selector<StateType>\n>\n\n/**\n * It provides a way to create structured selectors.\n * The structured selector can take multiple input selectors\n * and map their output to an object with specific keys.\n *\n * @template StateType - The type of state that the structured selectors created with this structured selector creator will operate on.\n *\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\n *\n * @public\n */\nexport interface StructuredSelectorCreator<StateType = any> {\n  /**\n   * A convenience function that simplifies returning an object\n   * made up of selector results.\n   *\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\n   * @returns A memoized structured selector.\n   *\n   * @example\n   * <caption>Modern Use Case</caption>\n   * ```ts\n   * import { createSelector, createStructuredSelector } from 'reselect'\n   *\n   * interface RootState {\n   *   todos: {\n   *     id: number\n   *     completed: boolean\n   *     title: string\n   *     description: string\n   *   }[]\n   *   alerts: { id: number; read: boolean }[]\n   * }\n   *\n   * // This:\n   * const structuredSelector = createStructuredSelector(\n   *   {\n   *     todos: (state: RootState) => state.todos,\n   *     alerts: (state: RootState) => state.alerts,\n   *     todoById: (state: RootState, id: number) => state.todos[id]\n   *   },\n   *   createSelector\n   * )\n   *\n   * // Is essentially the same as this:\n   * const selector = createSelector(\n   *   [\n   *     (state: RootState) => state.todos,\n   *     (state: RootState) => state.alerts,\n   *     (state: RootState, id: number) => state.todos[id]\n   *   ],\n   *   (todos, alerts, todoById) => {\n   *     return {\n   *       todos,\n   *       alerts,\n   *       todoById\n   *     }\n   *   }\n   * )\n   * ```\n   *\n   * @example\n   * <caption>In your component:</caption>\n   * ```tsx\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\n   * import type { FC } from 'react'\n   * import { useSelector } from 'react-redux'\n   *\n   * interface Props {\n   *   id: number\n   * }\n   *\n   * const MyComponent: FC<Props> = ({ id }) => {\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\n   *     structuredSelector(state, id)\n   *   )\n   *\n   *   return (\n   *     <div>\n   *       Next to do is:\n   *       <h2>{todoById.title}</h2>\n   *       <p>Description: {todoById.description}</p>\n   *       <ul>\n   *         <h3>All other to dos:</h3>\n   *         {todos.map(todo => (\n   *           <li key={todo.id}>{todo.title}</li>\n   *         ))}\n   *       </ul>\n   *     </div>\n   *   )\n   * }\n   * ```\n   *\n   * @example\n   * <caption>Simple Use Case</caption>\n   * ```ts\n   * const selectA = state => state.a\n   * const selectB = state => state.b\n   *\n   * // The result function in the following selector\n   * // is simply building an object from the input selectors\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\n   *   a,\n   *   b\n   * }))\n   *\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\n   * ```\n   *\n   * @template InputSelectorsObject - The shape of the input selectors object.\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\n   *\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\n   */\n  <\n    InputSelectorsObject extends SelectorsObject<StateType>,\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\n  >(\n    inputSelectorsObject: InputSelectorsObject,\n    selectorCreator?: CreateSelectorFunction<\n      MemoizeFunction,\n      ArgsMemoizeFunction\n    >\n  ): OutputSelector<\n    ObjectValuesToTuple<InputSelectorsObject>,\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\n    MemoizeFunction,\n    ArgsMemoizeFunction\n  > &\n    InterruptRecursion\n\n  /**\n   * Creates a \"pre-typed\" version of\n   * {@linkcode createStructuredSelector createStructuredSelector}\n   * where the `state` type is predefined.\n   *\n   * This allows you to set the `state` type once, eliminating the need to\n   * specify it with every\n   * {@linkcode createStructuredSelector createStructuredSelector} call.\n   *\n   * @returns A pre-typed `createStructuredSelector` with the state type already defined.\n   *\n   * @example\n   * ```ts\n   * import { createStructuredSelector } from 'reselect'\n   *\n   * export interface RootState {\n   *   todos: { id: number; completed: boolean }[]\n   *   alerts: { id: number; read: boolean }[]\n   * }\n   *\n   * export const createStructuredAppSelector =\n   *   createStructuredSelector.withTypes<RootState>()\n   *\n   * const structuredAppSelector = createStructuredAppSelector({\n   *   // Type of `state` is set to `RootState`, no need to manually set the type\n   *   todos: state => state.todos,\n   *   alerts: state => state.alerts,\n   *   todoById: (state, id: number) => state.todos[id]\n   * })\n   *\n   * ```\n   * @template OverrideStateType - The specific type of state used by all structured selectors created with this structured selector creator.\n   *\n   * @see {@link https://reselect.js.org/api/createstructuredselector#defining-a-pre-typed-createstructuredselector `createSelector.withTypes`}\n   *\n   * @since 5.1.0\n   */\n  withTypes: <\n    OverrideStateType extends StateType\n  >() => StructuredSelectorCreator<OverrideStateType>\n}\n\n/**\n * A convenience function that simplifies returning an object\n * made up of selector results.\n *\n * @param inputSelectorsObject - A key value pair consisting of input selectors.\n * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\n * @returns A memoized structured selector.\n *\n * @example\n * <caption>Modern Use Case</caption>\n * ```ts\n * import { createSelector, createStructuredSelector } from 'reselect'\n *\n * interface RootState {\n *   todos: {\n *     id: number\n *     completed: boolean\n *     title: string\n *     description: string\n *   }[]\n *   alerts: { id: number; read: boolean }[]\n * }\n *\n * // This:\n * const structuredSelector = createStructuredSelector(\n *   {\n *     todos: (state: RootState) => state.todos,\n *     alerts: (state: RootState) => state.alerts,\n *     todoById: (state: RootState, id: number) => state.todos[id]\n *   },\n *   createSelector\n * )\n *\n * // Is essentially the same as this:\n * const selector = createSelector(\n *   [\n *     (state: RootState) => state.todos,\n *     (state: RootState) => state.alerts,\n *     (state: RootState, id: number) => state.todos[id]\n *   ],\n *   (todos, alerts, todoById) => {\n *     return {\n *       todos,\n *       alerts,\n *       todoById\n *     }\n *   }\n * )\n * ```\n *\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\n *\n * @public\n */\nexport const createStructuredSelector: StructuredSelectorCreator =\n  Object.assign(\n    <\n      InputSelectorsObject extends SelectorsObject,\n      MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\n      ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\n    >(\n      inputSelectorsObject: InputSelectorsObject,\n      selectorCreator: CreateSelectorFunction<\n        MemoizeFunction,\n        ArgsMemoizeFunction\n      > = createSelector as CreateSelectorFunction<\n        MemoizeFunction,\n        ArgsMemoizeFunction\n      >\n    ) => {\n      assertIsObject(\n        inputSelectorsObject,\n        'createStructuredSelector expects first argument to be an object ' +\n          `where each property is a selector, instead received a ${typeof inputSelectorsObject}`\n      )\n      const inputSelectorKeys = Object.keys(inputSelectorsObject)\n      const dependencies = inputSelectorKeys.map(\n        key => inputSelectorsObject[key]\n      )\n      const structuredSelector = selectorCreator(\n        dependencies,\n        (...inputSelectorResults: any[]) => {\n          return inputSelectorResults.reduce((composition, value, index) => {\n            composition[inputSelectorKeys[index]] = value\n            return composition\n          }, {})\n        }\n      )\n      return structuredSelector\n    },\n    { withTypes: () => createStructuredSelector }\n  ) as StructuredSelectorCreator\n"]},"metadata":{},"sourceType":"module"}